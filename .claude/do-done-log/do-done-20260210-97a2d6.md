# Session: 20260210-97a2d6

---
*2026-02-10 13:12*

## Eli:
Base directory for this skill: /Users/sara/.claude/skills/terminal-title

# Terminal Title

## Overview

Automatically sets descriptive terminal window titles based on the task Claude is working on. Essential for developers running multiple Claude Code instances who need to quickly identify which terminal is handling which task.

## When to Use

**Always trigger this skill:**
- At the start of every session (first user prompt) — the hook only sets a raw clip as placeholder, you must replace it with a proper summary
- When switching to a substantially different task (e.g., from "API Integration" to "Database Migration")

**Trigger on task switches like these:**
- Switching from frontend work to backend work
- Moving from debugging to new feature development
- Changing from one module/component to a completely different one
- Starting work on a different part of the system (e.g., from auth to payments)

**Do NOT trigger for:**
- Follow-up questions about the same task ("Can you add a comment to that function?")
- Small refinements to current work ("Make it blue instead of red")
- Debugging the same feature you just built
- Clarifications ("What did you mean by X?")
- Iterating on the same component or module
- Mid-task status updates or progress checks

## How It Works

1. **Extract Task Summary**: Analyze the user's prompt to identify the high-level task
2. **Generate Title**: Create a concise, descriptive title (max 40 characters)
3. **Set Title**: Execute the `~/.claude/skills/terminal-title/scripts/set_title.sh` script with the generated title
4. **No Confirmation Needed**: This happens automatically in the background

## Title Format Guidelines

**Good titles:**
- "API Integration: Auth Flow"
- "Fix: Login Bug"
- "DB Migration: Users Table"
- "Build: Dashboard UI"
- "Refactor: Payment Module"

**Displayed as (with automatic folder prefix):**
- `my-project | API Integration: Auth Flow`
- `my-project | Fix: Login Bug`

**Bad titles:**
- Too long: "Implementing the 

[...truncated...]

## Claude:
Great exploration done. Here's what I found and my thoughts on your ideas:

## Current Landscape

**fn+cmd+Del** currently just flashes the focus border (debug-ish). **fn+shift+cmd+arrows** are completely unbound — wide open for z-order work. The modifier escalation pattern already establishes `cmd` = focus, so `shift+cmd` = z-order control is a natural fit.

## Key Combo Options

| Combo | Idea | Notes |
|-------|------|-------|
| **fn+shift+cmd+up** | Raise to top of z-order | One-shot, matches "up = higher" |
| **fn+shift+cmd+down** | Send to bottom of z-order | One-shot, matches "down = lower" |
| **fn+cmd+Del** | AOT toggle (on/off) | Repurpose from debug flash |
| **fn+shift+cmd+left/right** | Unassigned | Could be AOT on / AOT off explicitly |

## On the fn+cmd+Del Overloading Idea

The focus→AOT→AOT-off triple-press cycle is clever, but I'd worry about it in practice — if you just want to flash the border to see "where is my focus?", you have to be careful not to accidentally double-tap into AOT mode. A simpler split might be:

- **fn+cmd+Del**: AOT toggle (on if off, off if on) — yellow border appears/disappears as feedback
- Drop the flash-focus-highlight since the focus system already shows a blue border on every fn+cmd+arrow press

Or keep flash as a short-press vs long-press distinction, but that adds timing complexity.

## Yellow Persistent Border

Very doable. The mousemove.lua code already demonstrates persistent canvas borders that update with window geometry. For AOT:
- Track AOT windows in a table (window ID → canvas)
- Yellow variant of the existing continuous-corner border (`{red=1, green=0.85, blue=0, alpha=0.9}`)
- Use `hs.window.filter` to watch for move/resize/close events and update/remove the border
- Border survives across focus changes (unlike the 0.3s flash)

## Implementation Challenge: True AOT

Hammerspoon doesn't expose `hs.window:setLevel()` for other apps' windows — macOS window levels are owned by each process. Two practical approaches:

1. **Event-driven raise**: Use `hs.window.filter` to detect when another window activates and immediately re-raise the AOT window. Near-instant, no polling.
2. **Timer-based raise**: Poll `win:raise()` every ~0.3s. Simpler but can flicker.

Option 1 is cleaner. The AOT window would stay visually on top but you could still type in other windows (raise doesn't steal keyboard focus).

## Extra Ideas

- **fn+shift+cmd+up could double as "raise + AOT toggle"** if the window is already on top — press once to raise, press again to pin it (yellow border appears), press again to unpin
- **Auto-remove AOT when window is closed or minimized** — cleanup via window filter subscription
- `hs.window:sendToBack()` — I'm not certain this exists as a native method; may need to lower via ordering all other windows above it with `raise()`

